\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{listings}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algorithmic}
\usepackage{setspace, caption}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{hyperref}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Find reachability of a node v to node u in a graph
\\
{\footnotesize {
IV semester - Bachelorâ€™s of Technology in Information technology with specialization in Business Informatics,\\
Indian Institute of Information Technology Allahabad, India
}}
\thanks{}
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Aditya Raj}
\IEEEauthorblockA{\textit{IIB2019007} \\
iib2019007@iiita.ac.in \\
Adityahulk}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Shyam Tayal}
\IEEEauthorblockA{\textit{IIB2019008} \\
iib2019008@iiita.ac.in \\
shyamTayal}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Abhijeet Sonkar}
\IEEEauthorblockA{\textit{IIB2019009} \\
iiB2019009@iiita.ac.in \\
Abhijeet-sonkar}
}


\maketitle

\begin{abstract}
In this paper, we are devising an algorithm to a given directed graph, find out if a vertex v is reachable from another vertex u for all vertex pairs (u, v) in the given graph. Here reachable mean that there is a path from vertex u to v. The reach-ability matrix is called transitive closure of a graph.. This paper also analyzes the time and space complexity of the algorithms used and provides the most efficient approach to solve the given problem.
\end{abstract}
\bigskip
\begin{IEEEkeywords}
depth first search,floyd warshall algo,reach-ability matrix
\end{IEEEkeywords}

\section{Introduction}
Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.
The Floyd Warshall Algorithm is for solving the All Pairs Shortest Path problem. The problem is to find shortest distances between every pair of vertices in a given edge weighted directed Graph.

Steps of doing Dfs:-
Start by putting any one of the graph's vertices on top of a stack.
Take the top item of the stack and add it to the visited list.
Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the top of the stack.
Keep repeating steps 2 and 3 until the stack is empty.

Steps of Floyd-Warshall:-
We initialize the solution matrix same as the input graph matrix as a first step. Then we update the solution matrix by considering all vertices as an intermediate vertex. The idea is to one by one pick all vertices and updates all shortest paths which include the picked vertex as an intermediate vertex in the shortest path.
\bigskip
\section{Algorithm Design}
We have devised two algorithms to Find the possible pairs among n friends.

Implementing steps of DFS Algorithm->
We take all nodes and edges input and generate graph with an adjency list.Then we make an empty reachability matrix for representation of all paths.We run DFS algo function and mark nodes visted and then move to unvisited child of those nodes from adjency matrix correspondingly.

\bigskip
\begin{algorithm}[H]
\begin{lstlisting}
function dfs(curr, src):
    closure[src][curr]=1

    for(child in graph[curr]) :
        if closure[src][child] = 0 :
            dfs(child,src)

for v and u in n :
    dfs(v,v)
answer = closure[v][u]
\end{lstlisting}
 \caption{Depth first Search }
\end{algorithm}

The same problem can be solved out using Floyd Warshall's shortest path obtaining algorithm for all nodes.
\newline We initially maintain an nxn matrix (that stores shortest path between any two nodes) storing distance between adjacent nodes as given and other connected nodes as infinity.
\newline Then, We use Dynamic Programming approach to fill and update that matrix.We calculate distance between two nodes via other mid-nodes or direct distance and update with minimum distance as shortest path.
\bigskip

\begin{algorithm}[H]
\begin{lstlisting}
for k from 0 to n :
    for i from 0 to n :
        for j from 0 to n :
            x = closure[i][k]
            y = closure[k][j]
            z = closure[i][j]
            closure[i][j]= z || (x AND y)

given v and u
answer = closure[v][u]
\end{lstlisting}
 \caption{Floyd Warshall Algorithm}
\end{algorithm}
\bigskip

\section{Algorithm Analysis}
\bigskip
\begin{tabular}{ |p{3cm}||p{1.5cm}|p{1.5cm}| }
 \hline
 \multicolumn{3}{|c|}{Time and Space Complexity Comparison} \\
 \hline
 \textbf{Algorithms} &  \textbf{Time}& \textbf{Space} \\
 \hline
 DFS    &   O(N\textsuperscript{2})  & O(N\textsuperscript{2})\\
 \hline
 Floyd Warshall    &   O(N\textsuperscript{3})  & O(N\textsuperscript{2})\\
 \hline
\end{tabular}





\begin{figure}[h!]
\centerline{\includegraphics[width=80mm]{DFSvN.png}}
\caption{Algorithm 1 VS N}
\centerline{\textit{ }}
\label{fig:graph}
\end{figure}

\begin{figure}[h!]
\centerline{\includegraphics[width=80mm]{FlloydvN.png}}
\caption{Algorithm 2 VS N}
\centerline{\textit{ }}
\label{fig:graph}
\end{figure}

\newpage

\begin{figure}[h!]
\centerline{\includegraphics[width=80mm]{DFSnFloyd.png}}
\caption{Algorithm 1 vs Algorithm 2}
\centerline{\textit{ }}
\label{fig:graph}
\end{figure}

\section{Conclusion}


\begin{thebibliography}{00}
\bibitem{b1}https://en.wikipedia.org/wiki/Floyd\%E2\%80\%93Warshall\_algorithm
\bibitem{b2}https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/
\end{thebibliography}

\end{document}
